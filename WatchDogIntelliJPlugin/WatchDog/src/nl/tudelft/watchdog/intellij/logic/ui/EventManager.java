package nl.tudelft.watchdog.intellij.logic.ui;

import java.util.Date;

import com.intellij.openapi.editor.Editor;
import nl.tudelft.watchdog.core.logic.interval.intervaltypes.*;
import nl.tudelft.watchdog.core.logic.document.Document;
import nl.tudelft.watchdog.core.logic.ui.EventManagerBase;
import nl.tudelft.watchdog.core.logic.ui.InactivityNotifier;
import nl.tudelft.watchdog.core.logic.ui.UserInactivityNotifier;
import nl.tudelft.watchdog.intellij.logic.document.DocumentCreator;
import nl.tudelft.watchdog.intellij.logic.document.EditorWrapper;
import nl.tudelft.watchdog.intellij.logic.interval.IntervalManager;
import nl.tudelft.watchdog.intellij.logic.interval.intervaltypes.*;
import nl.tudelft.watchdog.core.logic.ui.events.WatchDogEvent;
import nl.tudelft.watchdog.core.logic.ui.events.WatchDogEvent.EventType;


/**
 * Manager for {@link nl.tudelft.watchdog.core.logic.ui.events.EditorEvent}s. Links such events to actions in the
 * IntervalManager, i.e. manages the creation and deletion of intervals based on
 * the incoming events. This class therefore contains the logic of when and how
 * new intervals are created, and how WatchDog reacts to incoming events
 * generated by its listeners.
 */
public class EventManager implements EventManagerBase{

    /**
     * The {@link nl.tudelft.watchdog.intellij.logic.InitializationManager} this observer is working with.
     */
    private final IntervalManager intervalManager;

    private final UserInactivityNotifier userInactivityNotifier;

    private final InactivityNotifier typingInactivityNotifier;

    private final InactivityNotifier readingInactivityNotifier;

    /**
     * Constructor.
     */
    public EventManager(final IntervalManager intervalManager,
                        int userActivityTimeout) {
        this.intervalManager = intervalManager;

        // the user inactivity timer additionally calls a new user event
        userInactivityNotifier = new UserInactivityNotifier(this,
                userActivityTimeout, EventType.USER_INACTIVITY);
        typingInactivityNotifier = new InactivityNotifier(this,
                userActivityTimeout, EventType.TYPING_INACTIVITY);
        readingInactivityNotifier = new InactivityNotifier(this,
                userActivityTimeout, EventType.READING_INACTIVITY);
    }

    /**
     * Simple proxy for {@link #update(nl.tudelft.watchdog.core.logic.ui.events.WatchDogEvent, java.util.Date)}, calling it with
     * the forcedDate set to "now".
     */
    public void update(WatchDogEvent event) {
        update(event, new Date());
    }

    /**
     * Introduces the supplied editorEvent, and sets the forcedDate to the
     * interval that is being created or closed.
     */
    public void update(WatchDogEvent event, Date forcedDate) {
        IntervalBase interval;
        switch (event.getType()) {
            case START_IDE:
                intervalManager.addInterval(new IDEOpenInterval(forcedDate));
                userInactivityNotifier.trigger(forcedDate);
                break;

            case END_IDE:
                userInactivityNotifier.cancelTimer(forcedDate);
                break;

            case ACTIVE_WINDOW:
                interval = intervalManager.getInterval(IDEActiveInterval.class);
                if (isClosed(interval)) {
                    intervalManager.addInterval(new IDEActiveInterval(
                            forcedDate));
                }
                userInactivityNotifier.trigger(forcedDate);
                break;

            case INACTIVE_WINDOW:
                interval = intervalManager.getInterval(IDEActiveInterval.class);
                intervalManager.closeInterval(interval, forcedDate);
                break;

            case JUNIT:
                JUnitInterval junitInterval = (JUnitInterval) event.getSource();
                intervalManager.addInterval(junitInterval);
                break;

            case USER_ACTIVITY:
                interval = intervalManager.getInterval(UserActiveInterval.class);
                if (isClosed(interval)) {
                    intervalManager.addInterval(new UserActiveInterval(forcedDate));
                }
                userInactivityNotifier.trigger();
                break;

            case START_EDIT:
                EditorIntervalBase editorInterval = intervalManager
                        .getEditorInterval();
                Editor editor = (Editor) event.getSource();

                readingInactivityNotifier.cancelTimer(forcedDate);
                if (intervalIsOfType(editorInterval, IntervalType.TYPING)
                        && ((EditorWrapper) editorInterval.getEditorWrapper()).getEditor() == editor) {
                    return;
                }

                intervalManager.closeInterval(editorInterval, forcedDate);

                TypingInterval typingInterval = new TypingInterval(new EditorWrapper(editor),
                        forcedDate);
                Document document = null;
                if (editorInterval != null && ((EditorWrapper) editorInterval.getEditorWrapper()).getEditor() == editor) {
                    document = editorInterval.getDocument();
                } else {
                    document = DocumentCreator.createDocument(editor);
                }
                typingInterval.setDocument(document);
                intervalManager.addInterval(typingInterval);

                typingInactivityNotifier.trigger();
                userInactivityNotifier.trigger(forcedDate);
                break;

            case SUBSEQUENT_EDIT:
                editorInterval = intervalManager.getEditorInterval();
                editor = (Editor) event.getSource();

                if (isClosed(editorInterval)
                        || !intervalIsOfType(editorInterval, IntervalType.TYPING)
                        || isDifferentEditor(editorInterval, editor)) {
                    update(new WatchDogEvent(event.getSource(),
                            EventType.START_EDIT));
                    break;
                }

                typingInactivityNotifier.trigger();
                userInactivityNotifier.trigger(forcedDate);
                break;

            case PAINT:
            case CARET_MOVED:
            case ACTIVE_FOCUS:
                editorInterval = intervalManager.getEditorInterval();
                editor = (Editor) event.getSource();
                if (needToCreateNewReadingInterval(editorInterval, editor)) {
                    if (!isClosed(editorInterval)) {
                        intervalManager.closeInterval(editorInterval, forcedDate);
                    }
                    ReadingInterval readingInterval = new ReadingInterval(new EditorWrapper(editor),
                            forcedDate);
                    readingInterval.setDocument(DocumentCreator
                            .createDocument(editor));
                    intervalManager.addInterval(readingInterval);
                }

                readingInactivityNotifier.trigger();
                userInactivityNotifier.trigger(forcedDate);
                break;

            case INACTIVE_FOCUS:
                editorInterval = intervalManager.getEditorInterval();
                intervalManager.closeInterval(editorInterval, forcedDate);
                readingInactivityNotifier.cancelTimer(forcedDate);
                typingInactivityNotifier.cancelTimer(forcedDate);
                break;

            case USER_INACTIVITY:
                interval = intervalManager.getInterval(UserActiveInterval.class);
                intervalManager.closeInterval(interval, forcedDate);
                typingInactivityNotifier.cancelTimer(forcedDate);
                readingInactivityNotifier.cancelTimer(forcedDate);
                break;

            case TYPING_INACTIVITY:
                editorInterval = intervalManager.getEditorInterval();
                if (intervalIsOfType(editorInterval, IntervalType.TYPING)) {
                    intervalManager.closeInterval(editorInterval, forcedDate);
                }
                break;

            case READING_INACTIVITY:
                editorInterval = intervalManager.getEditorInterval();
                if (intervalIsOfType(editorInterval, IntervalType.READING)) {
                    intervalManager.closeInterval(editorInterval, forcedDate);
                }
                break;

            case START_WATCHDOGVIEW:
                interval = intervalManager.getInterval(WatchDogViewInterval.class);
                if (!intervalIsOfType(interval, IntervalType.WATCHDOGVIEW)) {
                    intervalManager
                            .addInterval(new WatchDogViewInterval(forcedDate));
                }
                userInactivityNotifier.trigger(forcedDate);
                break;

            case END_WATCHDOGVIEW:
                interval = intervalManager.getInterval(WatchDogViewInterval.class);
                if (intervalIsOfType(interval, IntervalType.WATCHDOGVIEW)) {
                    intervalManager.closeInterval(interval, forcedDate);
                }
                break;

            default:
                break;
        }
    }

    private boolean needToCreateNewReadingInterval(
            EditorIntervalBase editorInterval, Editor editor) {
        return isClosed(editorInterval)
                || isDifferentEditor(editorInterval, editor);
    }

    private boolean isDifferentEditor(EditorIntervalBase editorInterval,
                                      Editor editor) {
        return ((EditorWrapper) editorInterval.getEditorWrapper()).getEditor() != editor;
    }

    private boolean intervalIsOfType(IntervalBase interval, IntervalType type) {
        return interval != null && interval.getType() == type;
    }

    private boolean isClosed(IntervalBase interval) {
        return interval == null || interval.isClosed();
    }

}
