package nl.tudelft.watchdog.logic.ui;

import nl.tudelft.watchdog.logic.InitializationManager;
import nl.tudelft.watchdog.logic.document.DocumentCreator;
import nl.tudelft.watchdog.logic.interval.IntervalManager;
import nl.tudelft.watchdog.logic.interval.intervaltypes.EditorIntervalBase;
import nl.tudelft.watchdog.logic.interval.intervaltypes.IntervalBase;
import nl.tudelft.watchdog.logic.interval.intervaltypes.IntervalType;
import nl.tudelft.watchdog.logic.interval.intervaltypes.JUnitInterval;
import nl.tudelft.watchdog.logic.interval.intervaltypes.PerspectiveInterval;
import nl.tudelft.watchdog.logic.interval.intervaltypes.PerspectiveInterval.Perspective;
import nl.tudelft.watchdog.logic.interval.intervaltypes.ReadingInterval;
import nl.tudelft.watchdog.logic.interval.intervaltypes.TypingInterval;
import nl.tudelft.watchdog.logic.logging.WatchDogLogger;
import nl.tudelft.watchdog.logic.ui.WatchDogEvent.EventType;

import org.eclipse.ui.texteditor.ITextEditor;

/**
 * Manager for {@link EditorEvent}s. Links such events to actions in the
 * IntervalManager, i.e. manages the creation and deletion of intervals based on
 * the incoming events. This class therefore contains the logic of when and how
 * new intervals are created, and how WatchDog reacts to incoming events
 * generated by its listeners.
 */
public class EventManager {

	/** The {@link InitializationManager} this observer is working with. */
	private IntervalManager intervalManager;

	private InactivityNotifier userInactivityNotifier;

	private InactivityNotifier typingInactivityNotifier;

	private InactivityNotifier readingInactivityNotifier;

	private DocumentCreator documentFactory;

	/** Constructor. */
	public EventManager(IntervalManager intervalManager,
			DocumentCreator documentFactory, int userActivityTimeout) {
		this.intervalManager = intervalManager;
		this.documentFactory = documentFactory;

		userInactivityNotifier = new InactivityNotifier(this,
				userActivityTimeout, EventType.USER_INACTIVITY);
		typingInactivityNotifier = new InactivityNotifier(this,
				userActivityTimeout, EventType.TYPING_INACTIVITY);
		readingInactivityNotifier = new InactivityNotifier(this,
				userActivityTimeout, EventType.READING_INACTIVITY);
	}

	/** Introduces the supplied editorEvent */
	public void update(WatchDogEvent event) {
		IntervalBase interval;
		switch (event.getType()) {
		case START_ECLIPSE:
			intervalManager.addInterval(new IntervalBase(
					IntervalType.ECLIPSE_OPEN));
			userInactivityNotifier.trigger();
			break;

		case END_ECLIPSE:
			userInactivityNotifier.cancelTimer();
			intervalManager.closeAllIntervals();
			break;

		case ACTIVE_WINDOW:
			intervalManager.addInterval(new IntervalBase(
					IntervalType.ECLIPSE_ACTIVE));
			userInactivityNotifier.trigger();
			break;

		case INACTIVE_WINDOW:
			interval = intervalManager
					.getIntervalOfType(IntervalType.ECLIPSE_ACTIVE);
			intervalManager.closeInterval(interval);
			userInactivityNotifier.cancelTimer();
			break;

		case START_JAVA_PERSPECTIVE:
			createNewPerspectiveInterval(Perspective.JAVA);
			userInactivityNotifier.trigger();
			break;

		case START_DEBUG_PERSPECTIVE:
			createNewPerspectiveInterval(Perspective.DEBUG);
			userInactivityNotifier.trigger();
			break;

		case START_UNKNOWN_PERSPECTIVE:
			createNewPerspectiveInterval(Perspective.OTHER);
			userInactivityNotifier.trigger();
			break;

		case JUNIT:
			JUnitInterval junitInterval = (JUnitInterval) event.getSource();
			intervalManager.addInterval(junitInterval);
			break;

		case USER_ACTIVITY:
			userInactivityNotifier.trigger();
			interval = intervalManager
					.getIntervalOfType(IntervalType.USER_ACTIVE);
			if (interval == null) {
				intervalManager.addInterval(new IntervalBase(
						IntervalType.USER_ACTIVE));
			}
			break;

		case START_EDIT:
			EditorIntervalBase editorInterval = intervalManager
					.getEditorInterval();
			ITextEditor editor = (ITextEditor) event.getSource();

			if (editorInterval == null
					|| editorInterval.getType() != IntervalType.TYPING) {
				readingInactivityNotifier.cancelTimer();
				// create new typing interval
				intervalManager.closeInterval(editorInterval);
				intervalManager
						.addEditorIntervalAndSetDocument(new TypingInterval(
								editor));
			}
			typingInactivityNotifier.trigger();
			userInactivityNotifier.trigger();
			break;

		case EDIT:
			long beginDate = System.currentTimeMillis();
			editorInterval = intervalManager.getEditorInterval();
			editor = (ITextEditor) event.getSource();

			if (editorInterval == null
					|| editorInterval.getType() != IntervalType.TYPING) {
				update(new WatchDogEvent(event.getSource(),
						EventType.START_EDIT));
				break;
			}

			TypingInterval typingInterval = (TypingInterval) editorInterval;
			try {
				// refresh document content
				typingInterval.setEndingDocument(documentFactory
						.createDocument(editor));
			} catch (IllegalArgumentException exception) {
				WatchDogLogger.getInstance().logSevere(exception);
			}
			typingInactivityNotifier.trigger();
			userInactivityNotifier.trigger();
			long endDate = System.currentTimeMillis();
			WatchDogLogger.getInstance().logInfo(
					"editEvent: " + Long.toString(endDate - beginDate));
			break;

		case PAINT:
		case CARET_MOVED:
		case ACTIVE_FOCUS:
			editorInterval = intervalManager.getEditorInterval();
			if (editorInterval == null) {
				editor = (ITextEditor) event.getSource();
				intervalManager
						.addEditorIntervalAndSetDocument(new ReadingInterval(
								editor));
			}
			readingInactivityNotifier.trigger();
			userInactivityNotifier.trigger();
			break;

		case INACTIVE_FOCUS:
			editorInterval = intervalManager.getEditorInterval();
			intervalManager.closeInterval(editorInterval);
			readingInactivityNotifier.cancelTimer();
			typingInactivityNotifier.cancelTimer();
			break;

		case USER_INACTIVITY:
			interval = intervalManager
					.getIntervalOfType(IntervalType.USER_ACTIVE);
			intervalManager.closeInterval(interval);
			typingInactivityNotifier.cancelTimer();
			readingInactivityNotifier.cancelTimer();
			break;

		case TYPING_INACTIVITY:
			editorInterval = intervalManager.getEditorInterval();
			if (editorInterval != null
					&& editorInterval.getType() == IntervalType.TYPING) {
				intervalManager.closeInterval(editorInterval);
			}
			break;

		case READING_INACTIVITY:
			editorInterval = intervalManager.getEditorInterval();
			if (editorInterval != null
					&& editorInterval.getType() == IntervalType.READING) {
				intervalManager.closeInterval(editorInterval);
			}
			break;

		default:
			break;
		}
	}

	/** Creates a new perspective Interval of the given type. */
	private void createNewPerspectiveInterval(
			PerspectiveInterval.Perspective perspecitveType) {
		PerspectiveInterval perspectiveInterval = intervalManager
				.getIntervalOfClass(PerspectiveInterval.class);
		if (perspectiveInterval != null
				&& perspectiveInterval.getPerspectiveType() == perspecitveType) {
			// abort if such an interval is already open.
			return;
		}
		intervalManager.closeInterval(perspectiveInterval);
		intervalManager.addInterval(new PerspectiveInterval(perspecitveType));
	}

}